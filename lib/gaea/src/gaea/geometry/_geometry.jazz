;;;==============
;;;  GaeaScheme
;;;==============
;;;
;;;; Gaea Geometry
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2021
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;    Alain Marcotte
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


;; TODO
;; - use vector-signed-angle everywhere
;; - look at using make-standard-lookat2
;;   - this probably implies removing the - in make-lookat-matrix! which would give use an identity matrix
;; - need to make very clear unit vectors requirements in function
;;   - validations!?
;;   - use unit in the name!?
;; - make remove-roll work on planets
;; - cleanup of all pitch and roll code
;; - cleanup of new person-motion code

;; QUESTIONS
;; - how can roll-free-up make any sense without getting a reference sight

;; NOTES
;; - from reading my understanding is that in 3d angle signs is arbitrary
;;   in 2d we use the up as a reference, so that to be able to do the same
;;   thing in 3d, we need some orthogonal reference
;;   from mathworks:
;;   You need to come up with a fixed normal vector, n, specifying the plane in in which a and b will always lie. Then, you modify your formula as follows
;;     theta = atan2 ( abs( cross (a, b) ), dot (a, b) ) * sign( dot( cross(a,b), n) )
;;   How you come up with the normal vector depends on details of problem that you haven't yet given us. Clearly a and b are not arbitrary 3D vectors in your case, if there is a distinction to be made between theta and -theta.


(module gaea.geometry jazz


(export (gaea.geometry.base)
        (gaea.geometry.classes)
        (gaea.geometry.syntax (phase syntax)))

(import (jazz.geometry)
        (gaea.geometry.base)
        (gaea.geometry.classes)
        (gaea.geometry.syntax (phase syntax))
        (gaea.homogeneous)
        (gaea.lookat)
        (gaea.math)
        (gaea.movement)
        (gaea.parallelepiped)
        (gaea.plane))


(proclaim (not check bounds)
          (warn optimizations))

(declare (optimize-dead-local-variables))


;;;
;;;; Vertex
;;;


(definition public inline (vertex-distance v1 <vertex> v2 <vertex>) <fl>
  (vertex-norm (vertex-& v2 v1)))


(definition public inline (vertex-distance! res <f64> v1 <vertex> v2 <vertex>) <f64>
  (vertex-norm! res (vertex-& v2 v1))
  res)


(definition public inline (vertex-near? v1 <vertex> v2 <vertex>) <bool>
  (< (vertex-distance& v1 v2) EPSILON))


(definition public inline (vertex-near-zero? vert <vertex>) <bool>
  (vertex-near? vert (vertex& 0. 0. 0.)))


(definition public (vertex-64->32 vert)
  (let ((x (f32& (vertex-x vert)))
        (y (f32& (vertex-y vert)))
        (z (f32& (vertex-z vert))))
    (vertex (f32-ref x)
            (f32-ref y)
            (f32-ref z))))


(definition public (dot-product u <vertex> v <vertex>) <fl>
  (+ (* (vertex-x u) (vertex-x v))
     (* (vertex-y u) (vertex-y v))
     (* (vertex-z u) (vertex-z v))))


(definition public (dot-product! res <f64> u <vertex> v <vertex>) <f64>
  (f64-set! res (+ (* (vertex-x u) (vertex-x v))
                   (* (vertex-y u) (vertex-y v))
                   (* (vertex-z u) (vertex-z v))))
  res)


(definition public (cross-product u <vertex> v <vertex>) <vertex>
  (let ((res (make-vertex)))
    (cross-product! res u v)
    res))


(definition public (cross-product! res <vertex> u <vertex> v <vertex>) <vertex>
  (let ((a (vertex-x u))
        (b (vertex-y u))
        (c (vertex-z u))
        (d (vertex-x v))
        (e (vertex-y v))
        (f (vertex-z v)))
    (vertex-x-set! res (- (* b f) (* c e)))
    (vertex-y-set! res (- (* c d) (* a f)))
    (vertex-z-set! res (- (* a e) (* b d))))
  res)


(definition public (cross-normal u <vertex> v <vertex>) <vertex>
  (cross-normal! (make-vertex) u v))


(definition public (cross-normal! res <vertex> u <vertex> v <vertex>) <vertex>
  (cross-product! res u v)
  (vertex-normalize! res res)
  res)


(definition public (cross-normal-safe! res <vertex> u <vertex> v <vertex>) <vertex>
  (cross-product! res u v)
  (vertex-normalize-safe! res res)
  res)


(definition public (plane-normal v1 <vertex> v2 <vertex> v3 <vertex>) <vertex>
  (plane-normal! (make-vertex) v1 v2 v3))


(definition public (plane-normal! res <vertex> v1 <vertex> v2 <vertex> v3 <vertex>) <vertex>
  (cross-normal! res
                 (vertex-& v2 v1)
                 (vertex-& v3 v1)))


(definition public (plane-normal-safe v1 <vertex> v2 <vertex> v3 <vertex>) <vertex>
  (plane-normal-safe! (make-vertex) v1 v2 v3))


(definition public (plane-normal-safe! res <vertex> v1 <vertex> v2 <vertex> v3 <vertex>) <vertex>
  (cross-normal-safe! res
                      (vertex-& v2 v1)
                      (vertex-& v3 v1)))


;; this function suffers from several drawbacks vs its signed equivalent
;; - severe precision problems when the angle is small
;; - the returned angle is always positive so we do not
;;   have the nice property (angle a b) = - (angle b a)
(definition public (vector-angle v1 <vertex> v2 <vertex>) <fl>
  (let ((dot (dot-product& v1 v2)))
    (cond ((< dot -1.) PI)
          ((> dot 1.) 0.)
          (else (acos dot)))))


(definition public (vector-signed-angle v1 <vertex> v2 <vertex> n <vertex>) <fl>
  (let ((perp (cross-product& v1 v2)))
    (* (atan (vertex-norm perp) (dot-product v1 v2))
       (flsign (dot-product perp n)))))


(definition public (vertical-angle dir <vertex> up <vertex>) <fl>
  (- (vector-angle dir up)
     PI/2))


(definition public (plane-angle x1 <fl> y1 <fl> x2 <fl> y2 <fl>) <fl>
  (let ((atanA (atan x1 y1))
        (atanB (atan x2 y2)))
    (let ((angle (- atanB atanA)))
      (if (>= angle 0.)
          angle
        (+ PI*2 angle)))))


(definition public (triangle-center v1 <vertex> v2 <vertex> v3 <vertex>) <vertex>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3)) 3.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3)) 3.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3)) 3.)))


(definition public (quad-center v1 <vertex> v2 <vertex> v3 <vertex> v4 <vertex>) <vertex>
  (vertex (/ (+ (vertex-x v1) (vertex-x v2) (vertex-x v3) (vertex-x v4)) 4.)
          (/ (+ (vertex-y v1) (vertex-y v2) (vertex-y v3) (vertex-y v4)) 4.)
          (/ (+ (vertex-z v1) (vertex-z v2) (vertex-z v3) (vertex-z v4)) 4.)))


(definition public (center-of-mass vertices <vector>) <vertex>
  (center-of-mass! (make-vertex) vertices))


(definition public (center-of-mass! res <vertex> vertices <vector>) <vertex>
  (vertex! res 0. 0. 0.)
  (loop (for vertex in-vector vertices)
        (vertex+! res res vertex))
  (vertex-scalar*! res res (/ 1. (vector-length vertices))))


(definition public (polygon-normal vertices <vector>) <vertex>
  (plane-normal (cast <vertex> (vector-ref vertices 0))
                (cast <vertex> (vector-ref vertices 1))
                (cast <vertex> (vector-ref vertices 2))))


(definition public (polygon-normal! res <vertex> vertices <vector>) <vertex>
  (plane-normal! res
                 (cast <vertex> (vector-ref vertices 0))
                 (cast <vertex> (vector-ref vertices 1))
                 (cast <vertex> (vector-ref vertices 2))))


(definition public (polygon-radius center <vertex> vertices <vector>) <fl>
  (let ((radius (f64& -1.)))
    (loop (for vertex in-vector vertices)
          (let ((dist (vertex-distance& center vertex)))
            (when (> dist radius)
              (f64-copy! radius dist))))
    (f64-ref radius)))


(definition public (polygon-radius! res <f64> center <vertex> vertices <vector>) <f64>
  (let ((radius (f64& -1.)))
    (loop (for vertex in-vector vertices)
          (let ((dist (vertex-distance& center vertex)))
            (when (> dist radius)
              (f64-copy! radius dist))))
    (f64-copy! res radius)
    res))


(definition public (transform-ray origin <vertex> dir <vertex> matrix <matrix>) <values>
  (let ((new-origin (matrix-transform-3x4 matrix origin))
        (new-dest (matrix-transform-3x4& matrix (vertex+& origin dir))))
    (values new-origin (vertex- new-dest new-origin))))


(definition public (transform-ray! values <values> origin <vertex> dir <vertex> matrix <matrix>) <values>
  (let ((new-origin (matrix-transform-3x4& matrix origin))
        (new-dest (matrix-transform-3x4& matrix (vertex+& origin dir))))
    (vertex-copy! (values-ref values 0) new-origin)
    (vertex-normalize! (values-ref values 1) (vertex-& new-dest new-origin))
    values))


(definition public (ray-point-distance p <vertex> d <vertex> vert <vertex>) <fl>
  (vertex-norm (cross-product& d (vertex-& vert p))))


(definition public (ray-point-distance! res <f64> p <vertex> d <vertex> vert <vertex>) <f64>
  (vertex-norm! res (cross-product& d (vertex-& vert p))))


(definition public (ray-point-horizontal-distance p <vertex> d <vertex> v <vertex>) <fl>
  (let ((d (vertex-normalize& (vertex& (vertex-x d) 0. (vertex-z d))))
        (v (vertex& (vertex-x v) (vertex-y p) (vertex-z v))))
    (ray-point-distance p d v)))


(definition public (ray-point-horizontal-distance! res <f64> p <vertex> d <vertex> v <vertex>) <fv>
  (let ((d (vertex-normalize& (vertex& (vertex-x d) 0. (vertex-z d))))
        (v (vertex& (vertex-x v) (vertex-y p) (vertex-z v))))
    (ray-point-distance! res p d v)))


(definition public (ray-triangle-distance p <vertex> d <vertex> v0 <vertex> v1 <vertex> v2 <vertex>) <fl>
  (f64-ref (ray-triangle-distance! (make-f64&) p d v0 v1 v2)))


(definition public (ray-triangle-distance! res <f64> p <vertex> d <vertex> v0 <vertex> v1 <vertex> v2 <vertex>) <f64>
  (let ((e1 (vertex-& v1 v0))
        (e2 (vertex-& v2 v0)))
    (let ((h (cross-product& d e2)))
      (let ((a (dot-product& e1 h)))
        (if (and (> a -0.00001) (< a 0.00001))
            (f64-set! res -1.)
          (let ((f (f64& (/ 1. a)))
                (s (vertex-& p v0)))
            (let ((b (dot-product& s h)))
              (let ((u (f64& (* f b))))
                (if (or (< u 0.0) (> u 1.0))
                    (f64-set! res -1.)
                  (let ((q (cross-product& s e1)))
                    (let ((c (dot-product& d q)))
                      (let ((v (f64& (* f c))))
                        (if (or (< v 0.0) (> (+ u v) 1.0))
                            (f64-set! res -1.)
                          ;; at this stage we can compute t to find out where
                          ;; the intersection point is on the line
                          (let ((d (dot-product& e2 q)))
                            (let ((t (f64& (* f d))))
                              (if (> t 0.00001) ;; ray intersection
                                  (f64-set! res t)
                                ;; this means that there is a line intersection
                                ;; but not a ray intersection
                                (f64-set! res -1.))))))))))))))))
  res)


(definition public (ray-intersects-triangle? p <vertex> d <vertex> v0 <vertex> v1 <vertex> v2 <vertex>) <bool>
  (let ((d (make-f64&)))
    (ray-triangle-distance! d p d v0 v1 v2)
    (/= d -1.)))


(definition public (ray-intersects-sphere? p <vertex> d <vertex> s <vertex> r <fv>) <bool>
  (let ((t (vertex-& p s)))
    (let ((i (dot-product& t d)))
      (let ((b (f64& (- i))))
        (let ((j (dot-product& t t)))
          (let ((det (f64& (+ (- (* b b) j) (* r r)))))
            (if (< det 0.)
                #f
              (f64-set! det (sqrt det))
              (let ((i (+ b det)))
                (>= i 0.)))))))))


;;;
;;;; Quaternion
;;;


(definition public (quaternion-inverse quat <quaternion>) <quaternion>
  (quaternion-scalar/ (quaternion-conjugate quat)
                      (quaternion-squared-norm quat)))


(definition public (quaternion-conjugate quat <quaternion>) <quaternion>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (quaternion (- x)
                (- y)
                (- z)
                w)))


(definition public (quaternion-norm quat <quaternion>) <fl>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (sqrt (+ (* x x)
             (* y y)
             (* z z)
             (* w w)))))


(definition public (quaternion-squared-norm quat <quaternion>) <fl>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (+ (* x x)
       (* y y)
       (* z z)
       (* w w))))


(definition public (quaternion-scalar* quat <quaternion> r <fl>) <quaternion>
  (quaternion
    (* (quaternion-x quat) r)
    (* (quaternion-y quat) r)
    (* (quaternion-z quat) r)
    (* (quaternion-w quat) r)))


(definition public (quaternion-scalar/ quat <quaternion> r <fl>) <quaternion>
  (quaternion
    (/ (quaternion-x quat) r)
    (/ (quaternion-y quat) r)
    (/ (quaternion-z quat) r)
    (/ (quaternion-w quat) r)))


(definition public (quaternion-product q1 <quaternion> q2 <quaternion>) <quaternion>
  (let ((x1 (quaternion-x q1))
        (y1 (quaternion-y q1))
        (z1 (quaternion-z q1))
        (w1 (quaternion-w q1))
        (x2 (quaternion-x q2))
        (y2 (quaternion-y q2))
        (z2 (quaternion-z q2))
        (w2 (quaternion-w q2)))
    (quaternion (+ (* w1 x2) (* x1 w2) (* y1 z2) (- (* z1 y2)))
                (+ (* w1 y2) (* y1 w2) (* z1 x2) (- (* x1 z2)))
                (+ (* w1 z2) (* z1 w2) (* x1 y2) (- (* y1 x2)))
                (+ (* w1 w2) (- (* x1 x2)) (- (* y1 y2)) (- (* z1 z2))))))


(definition public (translate-matrix! res <matrix> trans <vertex>) <matrix>
  (declare (optimize-dead-local-variables))
  (matrix-set! res 12 (vertex-x trans))
  (matrix-set! res 13 (vertex-y trans))
  (matrix-set! res 14 (vertex-z trans))
  res)


(definition public (euler->quaternion angles <vertex>) <quaternion>
  (euler->quaternion! (make-quaternion) angles))


(definition public (euler->quaternion! res <quaternion> angles <vertex>) <quaternion>
  (declare (optimize-dead-local-variables))
  (let ((rx (vertex-x angles))
        (ry (vertex-y angles))
        (rz (vertex-z angles)))
    (let ((sr (sin (* rx .5)))
          (sp (sin (* ry .5)))
          (sy (sin (* rz .5)))
          (cr (cos (* rx .5)))
          (cp (cos (* ry .5)))
          (cy (cos (* rz .5))))
      (quaternion-x-set! res (- (* sr cp cy) (* cr sp sy)))
      (quaternion-y-set! res (+ (* cr sp cy) (* sr cp sy)))
      (quaternion-z-set! res (- (* cr cp sy) (* sr sp cy)))
      (quaternion-w-set! res (+ (* cr cp cy) (* sr sp sy)))))
  res)


(definition public (quaternion->euler quat <quaternion>) <vertex>
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (vertex (atan (* 2. (+ (* w x) (* y z))) (- 1. (* 2. (+ (* x x) (* y y)))))
            (asin (* 2. (- (* w y) (* z x))))
            (atan (* 2. (+ (* w z) (* x y))) (- 1. (* 2. (+ (* y y) (* z z))))))))


(definition public (quaternion-matrix! res <matrix> quat <quaternion>) <matrix>
  (declare (optimize-dead-local-variables))
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (matrix-set! res  0 (- (- 1. (* 2. y y)) (* 2. z z)))
    (matrix-set! res  1 (+ (* 2. x y) (* 2. w z)))
    (matrix-set! res  2 (- (* 2. x z) (* 2. w y)))
    (matrix-set! res  4 (- (* 2. x y) (* 2. w z)))
    (matrix-set! res  5 (- (- 1. (* 2. x x)) (* 2. z z)))
    (matrix-set! res  6 (+ (* 2. y z) (* 2. w x)))
    (matrix-set! res  8 (+ (* 2. x z) (* 2. w y)))
    (matrix-set! res  9 (- (* 2. y z) (* 2. w x)))
    (matrix-set! res 10 (- (- 1. (* 2. x x)) (* 2. y y))))
  res)


(definition public (quaternion-slerp p <quaternion> q <quaternion> t <fv>) <quaternion>
  (quaternion-slerp! (make-quaternion) p q t))


(definition public (quaternion-slerp! res <quaternion> p <quaternion> q <quaternion> t <fv>) <quaternion>
  (declare (proper-tail-calls))
  (declare (optimize-dead-local-variables))
  (declare (inline))
  (declare (inlining-limit 1000))
  ;; decide if one of the quaternions is backwards
  (let ((a (f64& 0.))
        (b (f64& 0.)))
    (loop (for i from 0 below 4)
          (let ((pi (f64vector-ref p i))
                (qi (f64vector-ref q i)))
            (f64-set! a (+ a (let ((pi-qi (- pi qi))) (* pi-qi pi-qi))))
            (f64-set! b (+ b (let ((pi+qi (+ pi qi))) (* pi+qi pi+qi))))))
    (let ((q (quaternion-copy& q)))
      (when (> a b)
        (loop (for i from 0 below 4)
              (f64vector-set! q i (- (f64vector-ref q i)))))
      (let ((cosom
              (f64& (+ (* (quaternion-x p) (quaternion-x q))
                       (* (quaternion-y p) (quaternion-y q))
                       (* (quaternion-z p) (quaternion-z q))
                       (* (quaternion-w p) (quaternion-w q))))))
        (if (> (+ 1. cosom) 1e-8)
            (let ((sclp (make-f64&))
                  (sclq (make-f64&)))
              (if (> (- 1. cosom) 1e-8)
                  (let ((omega (acos cosom)))
                    (let ((sinom (sin omega)))
                      (f64-set! sclp (/ (sin (* (- 1. t) omega)) sinom))
                      (f64-set! sclq (/ (sin (* t omega)) sinom))))
                (begin
                  (f64-set! sclp (- 1. t))
                  (f64-set! sclq t)))
              (loop (for i from 0 below 4)
                    (f64vector-set! res i (+ (* sclp (f64vector-ref p i))
                                             (* sclq (f64vector-ref q i))))))
          (quaternion-x-set! res (- (quaternion-y p)))
          (quaternion-y-set! res (quaternion-x p))
          (quaternion-z-set! res (- (quaternion-w p)))
          (quaternion-w-set! res (quaternion-z p))
          (let ((sclp (sin (* (- 1. t) .5 PI)))
                (sclq (sin (* t .5 PI))))
            (loop (for i from 0 below 3)
                  (f64vector-set! res i (+ (* sclp (f64vector-ref p i))
                                           (* sclq (f64vector-ref res i))))))))))
  res)


(definition public (euler-radian->degree angles <vertex>) <vertex>
  (vertex (radian->degree (vertex-x angles))
          (radian->degree (vertex-y angles))
          (radian->degree (vertex-z angles))))


(definition public (euler-degree->radian angles <vertex>) <vertex>
  (vertex (degree->radian (vertex-x angles))
          (degree->radian (vertex-y angles))
          (degree->radian (vertex-z angles))))


;;;
;;;; Cuboid
;;;


(definition public (cuboid-size cuboid <cuboid>) <vertex>
  (vertex (- (cuboid-right cuboid) (cuboid-left cuboid))
          (- (cuboid-top cuboid) (cuboid-bottom cuboid))
          (- (cuboid-front cuboid) (cuboid-back cuboid))))


(definition public (cuboid-radiuses cuboid <cuboid>) <vertex>
  (vertex (/ (- (cuboid-right cuboid) (cuboid-left cuboid)) 2.)
          (/ (- (cuboid-top cuboid) (cuboid-bottom cuboid)) 2.)
          (/ (- (cuboid-front cuboid) (cuboid-back cuboid)) 2.)))


(definition public (cuboid-center cuboid <cuboid>) <vertex>
  (vertex (/ (+ (cuboid-right cuboid) (cuboid-left cuboid)) 2.)
          (/ (+ (cuboid-top cuboid) (cuboid-bottom cuboid)) 2.)
          (/ (+ (cuboid-front cuboid) (cuboid-back cuboid)) 2.)))


(definition public (unit-cube pos)
  (let ((x (vertex-x pos))
        (y (vertex-y pos))
        (z (vertex-z pos)))
    (cuboid (floor x)
            (floor y)
            (floor z)
            (ceiling x)
            (ceiling y)
            (ceiling z))))


(definition public (compute-vertices-bounds proc) <cuboid>
  (let ((left +inf.0)
        (bottom +inf.0)
        (back +inf.0)
        (right -inf.0)
        (top -inf.0)
        (front -inf.0))
    (proc (lambda (vert)
            (let ((x (vertex-x vert))
                  (y (vertex-y vert))
                  (z (vertex-z vert)))
              (when (< x left) (set! left x))
              (when (< y bottom) (set! bottom y))
              (when (< z back) (set! back z))
              (when (> x right) (set! right x))
              (when (> y top) (set! top y))
              (when (> z front) (set! front z)))))
    (cuboid left bottom back right top front)))


;;;
;;;; Matrix
;;;


(definition public (make-identity-matrix) <matrix>
  (make-identity-matrix! (make-matrix)))


(definition public (make-identity-matrix! res <matrix>) <matrix>
  (matrix-set! res  0 1.)
  (matrix-set! res  1 0.)
  (matrix-set! res  2 0.)
  (matrix-set! res  3 0.)
  (matrix-set! res  4 0.)
  (matrix-set! res  5 1.)
  (matrix-set! res  6 0.)
  (matrix-set! res  7 0.)
  (matrix-set! res  8 0.)
  (matrix-set! res  9 0.)
  (matrix-set! res 10 1.)
  (matrix-set! res 11 0.)
  (matrix-set! res 12 0.)
  (matrix-set! res 13 0.)
  (matrix-set! res 14 0.)
  (matrix-set! res 15 1.)
  res)


(definition public (identity-matrix? mat <matrix>) <bool>
  (matrix=? mat (make-identity-matrix&)))


(definition public (matrix-transpose-3x3! dst <matrix> src <matrix>) <matrix>
  (matrix-set! dst 0 (matrix-ref src 0))
  (matrix-set! dst 1 (matrix-ref src 4))
  (matrix-set! dst 2 (matrix-ref src 8))
  (matrix-set! dst 4 (matrix-ref src 1))
  (matrix-set! dst 5 (matrix-ref src 5))
  (matrix-set! dst 6 (matrix-ref src 9))
  (matrix-set! dst 8 (matrix-ref src 2))
  (matrix-set! dst 9 (matrix-ref src 6))
  (matrix-set! dst 10 (matrix-ref src 10))
  dst)


;; multiply a b corresponds to applying b and then a
(definition public (matrix-multiply a <matrix> b <matrix>) <matrix>
  (matrix-multiply! (make-matrix) a b))


(definition public (matrix-multiply! res <matrix> . matrices) <matrix>
  (matrix-multiply*! res matrices))


(definition public (matrix-multiply* . matrices) <matrix>
  (matrix-multiply*! (make-matrix) matrices))


(definition public (matrix-multiply*! res <matrix> matrices) <matrix>
  (let ((matrix (cast <matrix> (car matrices)))
        (others (cdr matrices)))
    (if (null? others)
        (matrix-copy! res matrix)
      (matrix-multiply2! res
                         matrix
                         ;; optimizes a copy
                         (if (null? (cdr others))
                             (car others)
                           (matrix-multiply*& others))))))


(definition public (matrix-multiply2! res <matrix> a <matrix> b <matrix>) <matrix>
  (let ((a0 (matrix-ref a 0)) (a4 (matrix-ref a 4)) (a8  (matrix-ref a 8))  (a12 (matrix-ref a 12))
        (a1 (matrix-ref a 1)) (a5 (matrix-ref a 5)) (a9  (matrix-ref a 9))  (a13 (matrix-ref a 13))
        (a2 (matrix-ref a 2)) (a6 (matrix-ref a 6)) (a10 (matrix-ref a 10)) (a14 (matrix-ref a 14))
        (a3 (matrix-ref a 3)) (a7 (matrix-ref a 7)) (a11 (matrix-ref a 11)) (a15 (matrix-ref a 15))
        (b0 (matrix-ref b 0)) (b4 (matrix-ref b 4)) (b8  (matrix-ref b 8))  (b12 (matrix-ref b 12))
        (b1 (matrix-ref b 1)) (b5 (matrix-ref b 5)) (b9  (matrix-ref b 9))  (b13 (matrix-ref b 13))
        (b2 (matrix-ref b 2)) (b6 (matrix-ref b 6)) (b10 (matrix-ref b 10)) (b14 (matrix-ref b 14))
        (b3 (matrix-ref b 3)) (b7 (matrix-ref b 7)) (b11 (matrix-ref b 11)) (b15 (matrix-ref b 15)))
    (matrix-set! res  0 (+ (* a0 b0)  (* a4 b1)  (* a8 b2)   (* a12 b3)))
    (matrix-set! res  4 (+ (* a0 b4)  (* a4 b5)  (* a8 b6)   (* a12 b7)))
    (matrix-set! res  8 (+ (* a0 b8)  (* a4 b9)  (* a8 b10)  (* a12 b11)))
    (matrix-set! res 12 (+ (* a0 b12) (* a4 b13) (* a8 b14)  (* a12 b15)))
    (matrix-set! res  1 (+ (* a1 b0)  (* a5 b1)  (* a9 b2)   (* a13 b3)))
    (matrix-set! res  5 (+ (* a1 b4)  (* a5 b5)  (* a9 b6)   (* a13 b7)))
    (matrix-set! res  9 (+ (* a1 b8)  (* a5 b9)  (* a9 b10)  (* a13 b11)))
    (matrix-set! res 13 (+ (* a1 b12) (* a5 b13) (* a9 b14)  (* a13 b15)))
    (matrix-set! res  2 (+ (* a2 b0)  (* a6 b1)  (* a10 b2)  (* a14 b3)))
    (matrix-set! res  6 (+ (* a2 b4)  (* a6 b5)  (* a10 b6)  (* a14 b7)))
    (matrix-set! res 10 (+ (* a2 b8)  (* a6 b9)  (* a10 b10) (* a14 b11)))
    (matrix-set! res 14 (+ (* a2 b12) (* a6 b13) (* a10 b14) (* a14 b15)))
    (matrix-set! res  3 (+ (* a3 b0)  (* a7 b1)  (* a11 b2)  (* a15 b3)))
    (matrix-set! res  7 (+ (* a3 b4)  (* a7 b5)  (* a11 b6)  (* a15 b7)))
    (matrix-set! res 11 (+ (* a3 b8)  (* a7 b9)  (* a11 b10) (* a15 b11)))
    (matrix-set! res 15 (+ (* a3 b12) (* a7 b13) (* a11 b14) (* a15 b15))))
  res)


(definition public (matrix-transform mat <matrix> vert <vertex>) <vertex>
  (matrix-transform! (make-vertex) mat vert))


(definition public (matrix-transform! res <vertex> mat <matrix> vert <vertex>) <vertex>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (let ((s (+ (* (matrix-ref mat 3) x) (* (matrix-ref mat 7) y) (* (matrix-ref mat 11) z) (matrix-ref mat 15))))
      (vertex-x-set! res (/ (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)) s))
      (vertex-y-set! res (/ (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)) s))
      (vertex-z-set! res (/ (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14)) s))))
  res)


(definition public (matrix-transform-3x4 mat <matrix> vert <vertex>) <vertex>
  (matrix-transform-3x4! (make-vertex) mat vert))


(definition public (matrix-transform-3x4! res <vertex> mat <matrix> vert <vertex>) <vertex>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (vertex-x-set! res (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)))
    (vertex-y-set! res (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)))
    (vertex-z-set! res (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14))))
  res)


(definition public (matrix-transform-normal inverse-mat <matrix> vert <vertex>) <vertex>
  (matrix-transform-normal! (make-vertex) inverse-mat vert))


(definition public (matrix-transform-normal! res <vertex> inverse-mat <matrix> vert <vertex>) <vertex>
  ;; use inverse-transpose matrix
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    ;; use finite to validate
    (cond-expand
      (finite
       (debug-assert (= (matrix-ref inverse-mat 3) 0.))
       (debug-assert (= (matrix-ref inverse-mat 7) 0.))
       (debug-assert (= (matrix-ref inverse-mat 11) 0.)))
      (else
       ;; hack around jazz generating (jazz:unspecified) which makes gambit box the previous floats
       (begin)))
    (vertex-x-set! res (+ (* (matrix-ref inverse-mat 0) x) (* (matrix-ref inverse-mat 1) y) (* (matrix-ref inverse-mat 2) z)))
    (vertex-y-set! res (+ (* (matrix-ref inverse-mat 4) x) (* (matrix-ref inverse-mat 5) y) (* (matrix-ref inverse-mat 6) z)))
    (vertex-z-set! res (+ (* (matrix-ref inverse-mat 8) x) (* (matrix-ref inverse-mat 9) y) (* (matrix-ref inverse-mat 10) z))))
  (vertex-normalize! res res)
  res)


(definition public (matrix+-transform-3x4 mat <matrix+> vert <vertex>) <vertex>
  (if mat
      (matrix-transform-3x4 mat vert)
    vert))


(definition public (matrix+-transform-3x4! res <vertex> mat <matrix+> vert <vertex>) <vertex>
  (if mat
      (matrix-transform-3x4! res mat vert)
    (vertex-copy! res vert)))


(definition public (matrix-transform-3x4-offset! res <f64vector> mat <matrix> vec <f64vector> offset <fx>) <f64vector>
  (let ((x (f64vector-ref vec offset))
        (y (f64vector-ref vec (+ offset 1)))
        (z (f64vector-ref vec (+ offset 2))))
    (vertex-x-set! res (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)))
    (vertex-y-set! res (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)))
    (vertex-z-set! res (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14))))
  res)


(definition public (matrix+-transform-3x4-offset! res <f64vector> mat <matrix+> vec <f64vector> offset <fx>) <f64vector>
  (if mat
      (matrix-transform-3x4-offset! res mat vec offset)
    (vertex! res
             (f64vector-ref vec offset)
             (f64vector-ref vec (+ offset 1))
             (f64vector-ref vec (+ offset 2)))))


(definition public (matrix-transform-3x4->offset! res <f64vector> offset <fx> mat <matrix> vert <vertex>) <f64vector>
  (let ((x (vertex-x vert))
        (y (vertex-y vert))
        (z (vertex-z vert)))
    (f64vector-set! res offset       (+ (* (matrix-ref mat 0) x) (* (matrix-ref mat 4) y) (* (matrix-ref mat 8) z) (matrix-ref mat 12)))
    (f64vector-set! res (+ offset 1) (+ (* (matrix-ref mat 1) x) (* (matrix-ref mat 5) y) (* (matrix-ref mat 9) z) (matrix-ref mat 13)))
    (f64vector-set! res (+ offset 2) (+ (* (matrix-ref mat 2) x) (* (matrix-ref mat 6) y) (* (matrix-ref mat 10) z) (matrix-ref mat 14))))
  res)


(definition public (matrix+-transform-3x4->offset! res <f64vector> offset <fx> mat <matrix+> vert <vertex>) <f64vector>
  (if mat
      (matrix-transform-3x4->offset! res offset mat vert)
    (f64vector-set! res offset       (vertex-x vert))
    (f64vector-set! res (+ offset 1) (vertex-y vert))
    (f64vector-set! res (+ offset 2) (vertex-z vert))
    res))


(definition public (make-translation-matrix t <vertex>) <matrix>
  (make-translation-matrix! (make-matrix) t))


(definition public (make-translation-matrix! res <matrix> t <vertex>) <matrix>
  (make-identity-matrix! res)
  (matrix-set! res 12 (vertex-x t))
  (matrix-set! res 13 (vertex-y t))
  (matrix-set! res 14 (vertex-z t))
  res)


(definition public (make-x-rotation-matrix phi <fl>) <matrix>
  (make-x-rotation-matrix! (make-matrix) phi))


(definition public (make-x-rotation-matrix! res <matrix> phi <fl>) <matrix>
  (make-identity-matrix! res)
  (let ((cos (cos phi))
        (sin (sin phi)))
    (matrix-set! res 5 cos)
    (matrix-set! res 6 (- sin))
    (matrix-set! res 9 sin)
    (matrix-set! res 10 cos))
  res)


(definition public (make-y-rotation-matrix theta <fl>) <matrix>
  (make-y-rotation-matrix! (make-matrix) theta))


(definition public (make-y-rotation-matrix! res <matrix> theta <fl>) <matrix>
  (make-identity-matrix! res)
  (let ((cos (cos theta))
        (sin (sin theta)))
    (matrix-set! res 0 cos)
    (matrix-set! res 2 sin)
    (matrix-set! res 8 (- sin))
    (matrix-set! res 10 cos))
  res)


(definition public (make-z-rotation-matrix psi <fl>) <matrix>
  (make-z-rotation-matrix! (make-matrix) psi))


(definition public (make-z-rotation-matrix! res <matrix> psi <fl>) <matrix>
  (make-identity-matrix! res)
  (let ((cos (cos psi))
        (sin (sin psi)))
    (matrix-set! res 0 cos)
    (matrix-set! res 1 (- sin))
    (matrix-set! res 4 sin)
    (matrix-set! res 5 cos))
  res)


(definition public (make-euler-matrix r <vertex>) <matrix>
  (make-euler-matrix! (make-matrix) r))


(definition public (make-euler-matrix! res <matrix> r <vertex>) <matrix>
  (matrix-multiply! res
                    (make-x-rotation-matrix& (vertex-x r))
                    (make-y-rotation-matrix& (vertex-y r))
                    (make-z-rotation-matrix& (vertex-z r))))


(definition public (make-rotation-matrix axis <vertex> angle <fl>) <matrix>
  (make-rotation-matrix! (make-matrix) axis angle))


(definition public (make-rotation-matrix! res <matrix> axis <vertex> angle <fl>) <matrix>
  (let ((c (cos angle))
        (s (sin angle))
        (x (vertex-x axis))
        (y (vertex-y axis))
        (z (vertex-z axis)))
    (let ((t (- 1. c)))
      (matrix-set! res  0 (+ (* x x t) c))
      (matrix-set! res  1 (+ (* x y t) (* z s)))
      (matrix-set! res  2 (- (* x z t) (* y s)))
      (matrix-set! res  3 0.)
      (matrix-set! res  4 (- (* x y t) (* z s)))
      (matrix-set! res  5 (+ (* t y y) c))
      (matrix-set! res  6 (+ (* y z t) (* x s)))
      (matrix-set! res  7 0.)
      (matrix-set! res  8 (+ (* x z t) (* y s)))
      (matrix-set! res  9 (- (* y z t) (* x s)))
      (matrix-set! res 10 (+ (* z z t) c))
      (matrix-set! res 11 0.)
      (matrix-set! res 12 0.)
      (matrix-set! res 13 0.)
      (matrix-set! res 14 0.)
      (matrix-set! res 15 1.)))
  res)


(definition public (rotate-vertex-upon angle <fl> axis <vertex> dir <vertex>) <vertex>
  (rotate-vertex-upon! (make-vertex) angle axis dir))


(definition public (rotate-vertex-upon! res <vertex> angle <fl> axis <vertex> dir <vertex>) <vertex>
  (let ((c <fl> (cos angle))
        (s <fl> (sin angle))
        (x (vertex-x axis))
        (y (vertex-y axis))
        (z (vertex-z axis))
        (i (vertex-x dir))
        (j (vertex-y dir))
        (k (vertex-z dir)))
    (let ((t (- 1. c)))
      (vertex-x-set! res (+ (* i (+ (* x x t) c))
                            (* j (- (* x y t) (* z s)))
                            (* k (+ (* x z t) (* y s)))))
      (vertex-y-set! res (+ (* i (+ (* y x t) (* z s)))
                            (* j (+ (* y y t) c))
                            (* k (- (* y z t) (* x s)))))
      (vertex-z-set! res (+ (* i (- (* z x t) (* y s)))
                            (* j (+ (* z y t) (* x s)))
                            (* k (+ (* z z t) c))))))
  res)


(definition public (make-quaternion-matrix quat <quaternion>) <matrix>
  (make-quaternion-matrix! (make-matrix) quat))


(definition public (make-quaternion-matrix! res <matrix> quat <quaternion>) <matrix>
  (declare (optimize-dead-local-variables))
  (let ((x (quaternion-x quat))
        (y (quaternion-y quat))
        (z (quaternion-z quat))
        (w (quaternion-w quat)))
    (matrix-set! res  0 (- (- 1. (* 2. y y)) (* 2. z z)))
    (matrix-set! res  1 (+ (* 2. x y) (* 2. w z)))
    (matrix-set! res  2 (- (* 2. x z) (* 2. w y)))
    (matrix-set! res  3 0.)
    (matrix-set! res  4 (- (* 2. x y) (* 2. w z)))
    (matrix-set! res  5 (- (- 1. (* 2. x x)) (* 2. z z)))
    (matrix-set! res  6 (+ (* 2. y z) (* 2. w x)))
    (matrix-set! res  7 0.)
    (matrix-set! res  8 (+ (* 2. x z) (* 2. w y)))
    (matrix-set! res  9 (- (* 2. y z) (* 2. w x)))
    (matrix-set! res 10 (- (- 1. (* 2. x x)) (* 2. y y)))
    (matrix-set! res 11 0.)
    (matrix-set! res 12 0.)
    (matrix-set! res 13 0.)
    (matrix-set! res 14 0.)
    (matrix-set! res 15 1.))
  res)


(definition public (make-scaling-matrix s <vertex>) <matrix>
  (make-scaling-matrix! (make-matrix) s))


(definition public (make-scaling-matrix! res <matrix> s <vertex>) <matrix>
  (make-identity-matrix! res)
  (matrix-set! res 0 (vertex-x s))
  (matrix-set! res 5 (vertex-y s))
  (matrix-set! res 10 (vertex-z s))
  res)


(definition public (make-lookat-matrix lookat <LookAt>) <matrix>
  (make-lookat-matrix! (make-matrix) lookat))


(definition public (make-lookat-matrix! res <matrix> lookat <LookAt>) <matrix>
  (make-identity-matrix! res)
  (let ((sight (get-sight lookat))
        (up (get-up lookat))
        (right (get-right lookat)))
    (matrix-set! res 0 (- (vertex-x right))) (matrix-set! res 4 (vertex-x up)) (matrix-set! res  8 (vertex-x sight))
    (matrix-set! res 1 (- (vertex-y right))) (matrix-set! res 5 (vertex-y up)) (matrix-set! res  9 (vertex-y sight))
    (matrix-set! res 2 (- (vertex-z right))) (matrix-set! res 6 (vertex-z up)) (matrix-set! res 10 (vertex-z sight)))
  res)


(definition public (make-inverse-lookat-matrix lookat <LookAt>) <matrix>
  (make-inverse-lookat-matrix! (make-matrix) lookat))


(definition public (make-inverse-lookat-matrix! res <matrix> lookat <LookAt>) <matrix>
  (make-identity-matrix! res)
  (let ((sight (get-sight lookat))
        (up (get-up lookat))
        (right (get-right lookat)))
    (matrix-set! res 0 (- (vertex-x right))) (matrix-set! res 1 (vertex-x up)) (matrix-set! res  2 (vertex-x sight))
    (matrix-set! res 4 (- (vertex-y right))) (matrix-set! res 5 (vertex-y up)) (matrix-set! res  6 (vertex-y sight))
    (matrix-set! res 8 (- (vertex-z right))) (matrix-set! res 9 (vertex-z up)) (matrix-set! res 10 (vertex-z sight)))
  res)


(definition public (sphere-matrices! sphere-matrix <matrix> inverse-matrix <matrix> origin <vertex> lookat <LookAt> radiuses <vertex>) <void>
  (matrix-multiply! sphere-matrix
                    (make-scaling-matrix& (vertex-inverse& radiuses))
                    (make-inverse-lookat-matrix& lookat)
                    (make-translation-matrix& (vertex-negate& origin)))
  (matrix-multiply! inverse-matrix
                    (make-translation-matrix& origin)
                    (make-lookat-matrix& lookat)
                    (make-scaling-matrix& radiuses)))


(definition public (make-perspective-matrix fov <fl> ratio <fl> near <fl> far <fl>) <matrix>
  (make-perspective-matrix! (make-matrix) fov ratio near far))


(definition public (make-perspective-matrix! res <matrix> fov <fl> ratio <fl> near <fl> far <fl>) <matrix>
  (make-identity-matrix! res)
  (let ((f (/ 1.0 (tan (* fov (/ PI 360.))))))
    (matrix-set! res  0 (/ f ratio))
    (matrix-set! res  5 f)
    (matrix-set! res 10 (/ (+ far near) (- near far)))
    (matrix-set! res 14 (/ (* 2. far near) (- near far)))
    (matrix-set! res 11 -1.)
    (matrix-set! res 15 0.))
  res)


(definition public (make-orthographic-matrix left <fl> right <fl> bottom <fl> top <fl> near <fl> far <fl>) <matrix>
  (make-orthographic-matrix! (make-matrix) left right bottom top near far))


(definition public (make-orthographic-matrix! res <matrix> left <fl> right <fl> bottom <fl> top <fl> near <fl> far <fl>) <matrix>
  (make-identity-matrix! res)
  (let ((width (- right left))
        (height (- top bottom))
        (depth (- far near)))
    (matrix-set! res  0 (/ 2. width))
    (matrix-set! res  5 (/ 2. height))
    (matrix-set! res 10 (/ -2. depth))
    (matrix-set! res 12 (- (/ (+ right left) width)))
    (matrix-set! res 13 (- (/ (+ top bottom) height)))
    (matrix-set! res 14 (- (/ (+ far near) depth)))
    (matrix-set! res 15 1.)
    res))


(definition public (make-view-matrix position <vertex> lookat <LookAt>) <matrix>
  (make-view-matrix! (make-matrix) position lookat))


;; hand-coded for performance
(definition public (make-view-matrix! res <matrix> position <vertex> lookat <LookAt>) <matrix>
  (let ((sight (get-sight lookat))
        (up (get-up lookat))
        (right (get-right lookat)))
    (let ((b12 (- (vertex-x position)))
          (b13 (- (vertex-y position)))
          (b14 (- (vertex-z position)))
          (a0 (vertex-x right))
          (a1 (vertex-x up))
          (a2 (- (vertex-x sight)))
          (a4 (vertex-y right))
          (a5 (vertex-y up))
          (a6 (- (vertex-y sight)))
          (a8 (vertex-z right))
          (a9 (vertex-z up))
          (a10 (- (vertex-z sight))))
      (matrix-set! res  0 a0)
      (matrix-set! res  1 a1)
      (matrix-set! res  2 a2)
      (matrix-set! res  3 0.)
      (matrix-set! res  4 a4)
      (matrix-set! res  5 a5)
      (matrix-set! res  6 a6)
      (matrix-set! res  7 0.)
      (matrix-set! res  8 a8)
      (matrix-set! res  9 a9)
      (matrix-set! res 10 a10)
      (matrix-set! res 11 0.)
      (matrix-set! res 12 (+ (* a0 b12) (* a4 b13) (* a8 b14)))
      (matrix-set! res 13 (+ (* a1 b12) (* a5 b13) (* a9 b14)))
      (matrix-set! res 14 (+ (* a2 b12) (* a6 b13) (* a10 b14)))
      (matrix-set! res 15 1.)
      res)))


(definition public (matrix-translation mat <matrix>) <vertex>
  (vertex (matrix-ref mat 12)
          (matrix-ref mat 13)
          (matrix-ref mat 14)))


(definition public (matrix-direction mat <matrix>) <vertex>
  (plane-normal (matrix-transform& mat (vertex& 0. 0. 0.))
                (matrix-transform& mat (vertex& 0. 1. 0.))
                (matrix-transform& mat (vertex& 1. 0. 0.))))


;;;
;;;; LookAt
;;;


(definition public (lookat? obj)
  (is? obj LookAt))


(definition public (make-lookat) <LookAt>
  (new LookAt))


(definition public (make-standard-lookat) <LookAt>
  (let ((lookat (make-lookat)))
    (standardize-lookat! lookat)
    lookat))


;; a try that seems a lot more consistent with opengl
(definition public (make-standard-lookat2) <LookAt>
  (let ((lookat (make-lookat)))
    (standardize-lookat2! lookat)
    lookat))


(definition public (lookat=? l1 <LookAt> l2 <LookAt>) <bool>
  (and (vertex=? (get-sight l1) (get-sight l2))
       (vertex=? (get-up l1) (get-up l2))))


(definition public (lookat/=? l1 <LookAt> l2 <LookAt>) <bool>
  (or (vertex/=? (get-sight l1) (get-sight l2))
      (vertex/=? (get-up l1) (get-up l2))))


(definition public (lookat-near? l1 <LookAt> l2 <LookAt>) <bool>
  (and (vertex-near? (get-sight l1) (get-sight l2))
       (vertex-near? (get-up l1) (get-up l2))))


(definition public (lookat sight <vertex> up <vertex> right <vertex>) <LookAt>
  (lookat! (make-lookat)
           sight
           up
           right))


(definition public (horizon-lookat sight <vertex>) <LookAt>
  (horizon-lookat! (make-lookat) sight))


(definition public (horizon-lookat! lookat <LookAt> sight <vertex>) <LookAt>
  (let ((up (vertex& 0. 1. 0.)))
    (let ((right (cross-product& sight up)))
      (lookat! lookat sight up right))))


(definition public (horizon-lookat!^ lookat <LookAt> sight <vertex>) <LookAt>
  (let ((up (vertex& 0. 1. 0.)))
    (let ((right (cross-product& sight up)))
      (lookat! lookat sight up right))))


(definition public (lookat! lookat <LookAt> sight <vertex> up <vertex> right <vertex>) <LookAt>
  (set-sight lookat sight)
  (set-up lookat up)
  (set-right lookat right)
  ;; use finite to validate
  (cond-expand
    (finite
     (validate-lookat lookat))
    (else))
  lookat)


(definition public (copy-lookat lookat <LookAt>) <LookAt>
  (lookat! (make-lookat)
           (get-sight lookat)
           (get-up lookat)
           (get-right lookat)))


(definition public (lookat-copy! dst <LookAt> src <LookAt>) <LookAt>
  (lookat! dst
           (get-sight src)
           (get-up src)
           (get-right src)))


(definition public (standardize-lookat! lookat <LookAt>) <void>
  (vertex! (get-sight lookat)  0.0  0.0 -1.0)
  (vertex! (get-up lookat)     0.0  1.0  0.0)
  (vertex! (get-right lookat)  1.0  0.0  0.0))


(definition public (standardize-lookat2! lookat <LookAt>) <void>
  (vertex! (get-sight lookat)  0.0  0.0  1.0)
  (vertex! (get-up lookat)     0.0  1.0  0.0)
  (vertex! (get-right lookat)  1.0  0.0  0.0))


(definition public (direction-lookat sight <vertex>) <LookAt>
  (direction-lookat! (make-lookat) sight))


(definition public (direction-lookat! res <LookAt> sight <vertex>) <LookAt>
  (let ((up (vertex& 0. 1. 0.)))
    (let ((right (cross-normal& sight up)))
      (let ((up (cross-normal& right sight)))
        (lookat! res sight up right)))))


(definition public (realign-lookat! res <LookAt> lookat <LookAt> new-up <vertex>) <LookAt>
  (let ((old-sight (get-sight lookat)))
    (let ((new-right (cross-product& old-sight new-up)))
      (let ((new-sight (cross-product& new-up new-right)))
        (lookat! res
                 (vertex-normalize& new-sight)
                 (vertex-normalize& new-up)
                 (vertex-normalize& new-right))))))


(definition public (realign-lookat-horizon! res <LookAt> lookat <LookAt> up <vertex> initial-gravity <vertex> final-gravity <vertex>) <LookAt>
  (let ((old-sight (get-sight lookat)))
    (let ((new-right (cross-normal& old-sight up)))
      ;; calculate plane rotation
      (let ((angle (vector-angle (cross-normal& final-gravity new-right)
                                 (cross-normal& initial-gravity new-right))))
        (let ((new-up (vertex-normalize& (rotate-vertex-upon& (- angle) new-right (cross-normal& new-right old-sight)))))
          (lookat! res
                   (cross-normal& new-up new-right)
                   new-up
                   new-right))))))


(definition public (rotate-lookat-vertical! res <LookAt> lookat <LookAt> angle <fl>) <void>
  (let ((right (get-right lookat)))
    (let ((sight (vertex-normalize& (rotate-vertex-upon& angle right (get-sight lookat)))))
      (let ((up (vertex-normalize& (rotate-vertex-upon& angle right (get-up lookat)))))
        (lookat! res
                 sight
                 up
                 right)))))


(definition public (rotate-lookat-vertical-up! res <LookAt> lookat <LookAt> angle <fl> up <vertex>) <void>
  (let ((sight-angle (vertical-angle (get-sight lookat) up))
        (epsilon -.001))
    (let ((angle (min (max angle (- sight-angle PI/2 epsilon)) (+ sight-angle PI/2 epsilon)))
          (roll-free-right (cross-normal& (get-sight lookat) up)))
      (rotate-lookat! res lookat angle roll-free-right))))


(definition public (rotate-lookat lookat <LookAt> angle <fl> axis <vertex>) <LookAt>
  (rotate-lookat! (make-lookat) lookat angle axis))


(definition public (rotate-lookat! res <LookAt> lookat <LookAt> angle <fl> axis <vertex>) <LookAt>
  (let ((sight (vertex-normalize& (rotate-vertex-upon& angle axis (get-sight lookat)))))
    (let ((up (vertex-normalize& (rotate-vertex-upon& angle axis (get-up lookat)))))
      (let ((right (cross-normal& sight up)))
        (lookat! res
                 sight
                 up
                 right)))))


(definition public (validate-lookat-normalized lookat <LookAt>) <void>
  (validate-vertex-normalized (get-sight lookat))
  (validate-vertex-normalized (get-up lookat))
  (validate-vertex-normalized (get-right lookat)))


(definition public (validate-lookat lookat <LookAt>) <void>
  (validate-lookat-normalized lookat)
  (let ((sight (get-sight lookat))
        (up (get-up lookat))
        (right (get-right lookat)))
    (let ((deduced-sight (cross-normal up right))
          (deduced-up (cross-normal right sight))
          (deduced-right (cross-normal sight up)))
      (assert (vertex-near? sight deduced-sight))
      (assert (vertex-near? up deduced-up))
      (assert (vertex-near? right deduced-right)))))


(definition public (present-lookat lookat <LookAt>) <void>
  (format "~{LookAt {a} {a} {a}}"
          (present-vertex (get-sight lookat))
          (present-vertex (get-up lookat))
          (present-vertex (get-right lookat))))


;;;
;;;; Pitch
;;;


(definition public (pitch-free? lookat <LookAt> world-up <vertex>)
  (near? (dot-product& (get-sight lookat) world-up) 0. .001))


(definition public (pitched? lookat <LookAt> world-up <vertex>)
  (not (pitch-free? lookat world-up)))


(definition public (pitch-lookat lookat <LookAt> angle <fl>) <LookAt>
  (pitch-lookat! (make-lookat) lookat angle))


(definition public (pitch-lookat! res <LookAt> lookat <LookAt> angle <fl>) <LookAt>
  (rotate-lookat! res lookat angle (get-right lookat)))


;; todo correctly with alain
(definition public (remove-pitch-quick-hack dir <vertex>)
  (vertex-normalize (vertex& (vertex-x dir) 0. (vertex-z dir))))


(definition public (remove-pitch dir <vertex> lookat <LookAt>) <vertex>
  (let ((sight (get-sight lookat)))
    (vertex-normalize (vertex-& dir (vertex-scalar*& sight (dot-product& sight dir))))))


(definition public (remove-up-pitch dir <LookAt> lookat <LookAt>) <LookAt>
  (remove-up-pitch! (make-lookat) dir lookat))


(definition public (remove-up-pitch! res <LookAt> dir <LookAt> lookat <LookAt>) <LookAt>
  (let ((up (remove-pitch dir lookat)))
    (let ((sight (cross-normal& up (get-right lookat))))
      (let ((right (cross-normal& sight up)))
        (lookat! res
                 sight
                 up
                 right)))))


;;;
;;;; Roll
;;;


(definition public (roll-free? lookat <LookAt> world-up <vertex>)
  (near? (dot-product& (get-right lookat) world-up) 0. .001))


(definition public (rolled? lookat <LookAt> world-up <vertex>)
  (not (roll-free? lookat world-up)))


(definition public (roll-lookat lookat <LookAt> angle <fl>) <LookAt>
  (roll-lookat! (make-lookat) lookat angle))


(definition public (roll-lookat! res <LookAt> lookat <LookAt> angle <fl>) <LookAt>
  (rotate-lookat! res lookat angle (get-sight lookat)))


(definition public (remove-roll dir <vertex> lookat <LookAt>) <vertex>
  (let ((right (get-right lookat)))
    (vertex-normalize (vertex-& dir (vertex-scalar*& right (dot-product& right dir))))))


(definition public (remove-up-roll dir <LookAt> lookat <LookAt>) <LookAt>
  (remove-up-roll! (make-lookat) dir lookat))


(definition public (remove-up-roll! res <LookAt> dir <vertex> lookat <LookAt>) <LookAt>
  (let ((up (remove-roll dir lookat)))
    (let ((sight (cross-normal& up (get-right lookat))))
      (let ((right (cross-normal& sight up)))
        (lookat! res
                 sight
                 up
                 right)))))


(definition public (roll-free-up dir <vertex>) <vertex>
  (roll-free-up! (make-vertex) dir))


(definition public (roll-free-up! res <vertex> dir <vertex>) <vertex>
  (let ((x (vertex-x dir))
        (y (vertex-y dir))
        (z (vertex-z dir)))
    (let ((xz-norm (sqrt (+ (* x x) (* z z)))))
      (if (= xz-norm 0.)
          (vertex! res 0. 0. 1.)
        (let ((new-x (- (/ (* x y) xz-norm)))
              (new-z (- (/ (* z y) xz-norm))))
          (vertex! res new-x xz-norm new-z)))))
  res)


;;;
;;;; Parallelepiped
;;;


(definition public (parallelepiped left/bottom/back <vertex> left/bottom/front <vertex> left/top/back <vertex> left/top/front <vertex> right/bottom/back <vertex> right/bottom/front <vertex> right/top/back <vertex> right/top/front <vertex>) <Parallelepiped>
  (let ((para (new Parallelepiped)))
    (set-left/bottom/back para left/bottom/back)
    (set-left/bottom/front para left/bottom/front)
    (set-left/top/back para left/top/back)
    (set-left/top/front para left/top/front)
    (set-right/bottom/back para right/bottom/back)
    (set-right/bottom/front para right/bottom/front)
    (set-right/top/back para right/top/back)
    (set-right/top/front para right/top/front)
    para))


(definition public (make-parallelepiped) <Parallelepiped>
  (new Parallelepiped))


;;;
;;;; Gravity
;;;


(definition public (gravity-up gravity <vertex>) <vertex>
  (gravity-up! (make-vertex) gravity))


(definition public (gravity-up! res <vertex> gravity <vertex>) <vertex>
  (vertex-scalar*! res (vertex-normalize& gravity) -1.))


;;;
;;;; Movement
;;;


(definition public (copy-movement mvt <Movement>) <Movement>
  (new Movement (get-origin mvt) (get-vector mvt)))


(definition public (copy-movement! dst <Movement> src <Movement>) <Movement>
  (set-origin dst (get-origin src))
  (set-vector dst (get-vector src))
  dst)


(definition public (movement-end mvt <Movement>) <vertex>
  (vertex+ (get-origin mvt) (get-vector mvt)))


(definition public (movement-end! res <vertex> mvt <Movement>) <vertex>
  (vertex+! res (get-origin mvt) (get-vector mvt)))


(definition public (movement-end-to mvt <Movement> d <fv>) <vertex>
  (vertex+ (get-origin mvt) (vertex-scalar*& (get-normal mvt) d)))


(definition public (movement-end-to! res <vertex> mvt <Movement> d <fv>) <vertex>
  (vertex+! res (get-origin mvt) (vertex-scalar*& (get-normal mvt) d)))


(definition public (movement-transform-3x4 mvt <Movement> matrix <matrix>) <void>
  (let ((origin (get-origin mvt))
        (vector (get-vector mvt)))
    (let ((new-origin (matrix-transform-3x4& matrix origin)))
      (let ((new-vector (vertex-& (matrix-transform-3x4& matrix (vertex+& vector origin)) new-origin)))
        (new Movement new-origin new-vector)))))


(definition public (movement-transform-3x4! mvt <Movement> matrix <matrix>) <void>
  (let ((origin (get-origin mvt))
        (vector (get-vector mvt)))
    (let ((new-origin (matrix-transform-3x4& matrix origin)))
      (let ((new-vector (vertex-& (matrix-transform-3x4& matrix (vertex+& vector origin)) new-origin)))
        (set-origin mvt new-origin)
        (set-vector mvt new-vector)))))


;;;
;;;; Plane
;;;


(definition public (copy-plane plane <Plane>) <Plane>
  (allocate Plane
            (copy-vertex (get-origin plane))
            (copy-vertex (get-normal plane))))


(definition public (transform-plane$ plane <Plane> matrix <matrix> inverse-matrix <matrix>) <Plane>
  (let ((origin (get-origin plane))
        (normal (get-normal plane)))
    (make-plane$
      (matrix-transform-3x4& matrix origin)
      (matrix-transform-normal& inverse-matrix normal))))


(definition public (plane-to-point-distance& plane <Plane> point <vertex>) <fv>
  (dot-product& (get-normal plane) (vertex-& point (get-origin plane))))


(definition public (intersect-plane plane <Plane> r <Movement>) <values>
  (let ((dist (make-f64)))
    (let ((intersect? (intersect-plane! dist plane r)))
      (values (f64-ref dist) intersect?))))


(definition public (intersect-plane! res <f64> plane <Plane> r <Movement>) <bool>
  (let ((origin (get-origin plane))
        (normal (get-normal plane)))
    (let ((denom (dot-product& normal (get-normal r))))
      (if (= denom 0.)
          (begin
            (f64-set! res 0.)
            #f)
        (let ((numer (dot-product& normal (get-origin r)))
              (distance (- (dot-product& origin normal))))
          (f64-set! res (- (/ (+ numer distance) denom)))
          #t)))))


(definition public (plane-closest plane <Plane> point <vertex>) <vertex>
  (plane-closest! (make-vertex) plane point))


(definition public (plane-closest! res <vertex> plane <Plane> point <vertex>) <vertex>
  (let ((t (plane-to-point-distance& plane point)))
    (vertex-! res point (vertex-scalar*& (get-normal plane) t)))
  res)


;;;
;;;; Polygon
;;;


(definition public (closest-point-on-line-segment a <vertex> b <vertex> p <vertex>) <values>
  (let ((pt (make-vertex)))
    (let ((edge? (closest-point-on-line-segment! pt a b p)))
      (values pt edge?))))


(definition public (closest-point-on-line-segment! res <vertex> a <vertex> b <vertex> p <vertex>) <bool>
  (let ((on-edge #t)
        (c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (dot-product& v c)))
      (if (< t 0.)
          (begin
            (vertex-copy! res a)
            (not on-edge))
        (let ((d (vertex-distance& b a)))
          (if (> t d)
              (begin
                (vertex-copy! res b)
                (not on-edge))
            (vertex+! res a (vertex-scalar*& v t))
            on-edge))))))


(definition public (closest-point-on-line a <vertex> b <vertex> p <vertex>) <vertex>
  (closest-point-on-line! (make-vertex) a b p))


(definition public (closest-point-on-line! res <vertex> a <vertex> b <vertex> p <vertex>) <vertex>
  (let ((c (vertex-& p a))
        (v (vertex-normalize& (vertex-& b a))))
    (let ((t (dot-product& v c))
          (d (vertex-distance& b a)))
      (vertex+! res a (vertex-scalar*& v t))))
  res)


;;;
;;;; Random
;;;


(definition public (random-horizon)
  (let ((x (random-between -1. 1.))
        (y 0.)
        (z (random-between -1. 1.)))
    (let ((dir (vertex-normalize-safe (vertex x y z))))
      (if (vertex-zero? dir)
          (random-horizon)
        dir))))


(definition public (random-direction)
  (let ((x (random-between -1. 1.))
        (y (random-between -1. 1.))
        (z (random-between -1. 1.)))
    (let ((dir (vertex-normalize-safe (vertex x y z))))
      (if (vertex-zero? dir)
          (random-direction)
        dir))))


(definition public (random-upward-fly)
  (let ((x (random-between 0. 1.))
        (y (random-between 0. 1.))
        (z (random-between 0. 1.)))
    (let ((dir (vertex-normalize-safe (vertex x y z))))
      (if (or (vertex-zero? dir)
              (float-near? y 1.)
              (float-near? y -1.))
          (random-upward-fly)
        dir))))


(definition public (random-fly)
  (let ((x (random-between -1. 1.))
        (y (random-between  0. 1.))
        (z (random-between -1. 1.)))
    (let ((dir (vertex-normalize-safe (vertex x y z))))
      (if (or (vertex-zero? dir)
              (float-near? y 1.)
              (float-near? y -1.))
          (random-fly)
        dir)))))
