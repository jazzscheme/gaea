;;;==============
;;;  JazzScheme
;;;==============
;;;
;;;; OpenGL Frame
;;;
;;;  The contents of this file are subject to the Mozilla Public License Version
;;;  1.1 (the "License"); you may not use this file except in compliance with
;;;  the License. You may obtain a copy of the License at
;;;  http://www.mozilla.org/MPL/
;;;
;;;  Software distributed under the License is distributed on an "AS IS" basis,
;;;  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
;;;  for the specific language governing rights and limitations under the
;;;  License.
;;;
;;;  The Original Code is JazzScheme.
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 1996-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):
;;;
;;;  Alternatively, the contents of this file may be used under the terms of
;;;  the GNU General Public License Version 2 or later (the "GPL"), in which
;;;  case the provisions of the GPL are applicable instead of those above. If
;;;  you wish to allow use of your version of this file only under the terms of
;;;  the GPL, and not to allow others to use your version of this file under the
;;;  terms of the MPL, indicate your decision by deleting the provisions above
;;;  and replace them with the notice and other provisions required by the GPL.
;;;  If you do not delete the provisions above, a recipient may use your version
;;;  of this file under the terms of any one of the MPL or the GPL.
;;;
;;;  See www.jazzscheme.org for details.


(module gaea.window.frame jazz


(import (jazz.cairo)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.platform)
        (jazz.screen)
        (jazz.settings)
        (jazz.view)
        (jazz.window)
        (gaea.array)
        (gaea.buffer)
        (gaea.geometry)
        (gaea.pipeline)
        (gaea.program)
        (gaea.render)
        (gaea.shader)
        (gaea.texture)
        (gaea.uniform)
        (gaea.window))


;;;
;;;; Interface
;;;


(definition interface-sources
  (list
    ;; metal
    (list
#/C/
    #include <metal_stdlib>
    
    using namespace metal;

    struct vs_in
    {
        float4 position  [[attribute(0)]];
        float2 texCoords [[attribute(1)]];
    };

    struct vs_out
    {
        float4 position [[position]];
        float2 texCoords;
    };

    struct Uniforms
    {
        float4x4 orthographicMatrix;
    };

    vertex vs_out vertex_simple(
        vs_in vertexIn [[stage_in]],
        constant Uniforms *uniforms  [[buffer(0)]])
    {
        vs_out vertexOut;
        vertexOut.position = uniforms->orthographicMatrix * vertexIn.position;
        vertexOut.texCoords = vertexIn.texCoords;
        return vertexOut;
    }
    
    fragment float4 fragment_simple(
        vs_out vert [[stage_in]],
        texture2d<float, access::sample> tex [[texture(0)]],
        sampler samplr [[sampler(0)]])
    {
        return tex.sample(samplr, vert.texCoords);
    }
//#
      "vertex_simple"
      "fragment_simple")
    
    ;; opengl
    (list
      ;; vertex
      (string-append glsl-version
#/C/
    layout (std140) uniform Matrices
    {
        mat4 orthographic_matrix;
    };

    in vec4 position;
    in vec3 texture_coord;

    out vec3 final_texture;

    void main()
    {
        gl_Position = orthographic_matrix * position;
        final_texture = texture_coord;
    }
//#)
      ;; fragment
      (string-append glsl-version
#/C/
    uniform sampler2D textureSampler;

    in vec3 final_texture;

    out vec4 fragColor;

    void main()
    {
        fragColor = texture(textureSampler, vec2(final_texture.x, final_texture.y));
    }
//#))))


(definition interface-layout
  (list
    (list 1 (* 8 float-size)
      (list "position"      'float4 0)
      (list "texture_coord" 'float2 (* 4 float-size)))))


;;;
;;;; Frame
;;;


(class Gaea-Frame extends Gaea-Window
  
  
  (slot interface-pipeline  initialize #f getter generate)
  (slot interface-array     initialize #f getter generate)
  (slot interface-texture   initialize #f getter generate)
  (slot interface-binding   initialize 0  getter generate)
  (slot interface-uniform   initialize #f getter generate)
  (slot orthographic-matrix initialize (make-matrix) getter generate)
  (slot render-thread       initialize #f getter generate)
  
  
  (method protected virtual (default-render? self)
    #t)
  
  
  (method override (setup-engine self)
    (nextmethod self)
    (when (default-render? self)
      (create-pipelines self)
      (initialize-arrays self)
      (setup-textures self)))
  
  
  ;;;
  ;;;; Pipelines
  ;;;
  
  
  (method (create-pipelines self)
    (set! interface-pipeline (new Pipeline (new Program interface-sources) interface-layout))
    (gaea-uniform-binding interface-pipeline interface-binding))
  
  
  ;;;
  ;;;; Arrays
  ;;;
  
  
  (method (initialize-arrays self)
    (let ((content #f32(  0.0 10.0 0.0 1.0   0.0 0.0 0.0 0.0
                         10.0 10.0 0.0 1.0   1.0 0.0 0.0 0.0
                          0.0  0.0 0.0 1.0   0.0 1.0 0.0 0.0
                         10.0  0.0 0.0 1.0   1.0 1.0 0.0 0.0
                          0.0  0.0 0.0 1.0   0.0 1.0 0.0 0.0
                         10.0 10.0 0.0 1.0   1.0 0.0 0.0 0.0 )))
      (let ((buffer (new Buffer content)))
        (set! interface-array (new Array interface-pipeline 1 6 buffer)))))
  
  
  ;;;
  ;;;; Textures
  ;;;
  
  
  (method (setup-textures self)
    (set! interface-texture (make-cairo-texture (get-width self) (get-height self) scale?: #t))
    (setup-uniform interface-texture interface-pipeline "texture_sampler"))
  
  
  ;;;
  ;;;; Resize
  ;;;
  
  
  (method override (resize-scene self width <fl> height <fl>)
    (nextmethod self width height)
    (when (default-render? self)
      ;; Orthographic
      (make-orthographic-matrix! orthographic-matrix 0.0 10.0 0.0 10.0 0.0 10.0)
      ;; Texture
      (when interface-texture
        (close interface-texture)
        (setup-textures self))
      ;; Uniform
      (let ((content (make-f32vector 16)))
        (matrix-transfer! orthographic-matrix content 0)
        (set! interface-uniform (new Uniform-Buffer interface-binding content)))))
  
  
  ;;;
  ;;;; Interface
  ;;;
  
  
  ;; helps with scaling artefacts that
  ;; the background be white and not black
  (method (clear-background self)
    (cond-expand
      (windows
       (glClearColor 1.0 1.0 1.0 1.0)
       (glClear (bitwise-ior GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT)))
      (else)))
  
  
  ;; helps with scaling artefacts that
  ;; the background be white and not black
  (method (fill-background self surface)
    (cond-expand
      (windows
       (set-color surface {Color White})
       (paint surface))
      (else
       (clear surface))))

    
  (method (draw-interface self)
    (when (window-region-invalid? handle)
      (let ((surface (get-surface interface-texture))
            (rect (get-box (get-window-invalid-region handle))))
        (let ((clipper (fix-clipper rect)))
          (set-clipper surface clipper)
          (fill-background self surface)
          (paint-drawing-rect root surface rect '())
          (flush surface)
          (map-subtexture interface-texture clipper)
          (validate-window handle)))))
  
  
  (method public (render-interface self)
    ;; (glEnable GL_BLEND)
    ;; (glDisable GL_DEPTH_TEST)
    (with-render self
      (lambda (encoder)
        (gaea-bind-uniform encoder interface-uniform 0)
        (with-pipeline interface-pipeline encoder
          (lambda ()
            (bind-texture interface-texture encoder)
            (draw-array interface-array encoder))))))
  
  
  ;;;
  ;;;; Draw
  ;;;
  
  
  (method override (draw-scene self)
    (when (default-render? self)
      ;; Interface
      (clear-background self)
      (draw-interface self)
      (render-interface self)))))
